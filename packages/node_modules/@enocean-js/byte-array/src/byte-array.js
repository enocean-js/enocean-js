export default class ByteArray extends Array {
  set (arr, offset = 0) {
    var tmp = ByteArray.from(arr)
    if (tmp.length === 0) return
    this.splice(offset, tmp.length, ...tmp)
  }

  getValue (bitOffset, bitLength) {
    if (bitLength === 0) return 0
    return parseInt(this.toString(2).substr(bitOffset, bitLength), 2)
  }

  setValue (value, offset, bitLength) {
    var bits = value.toString(2).padStart(bitLength, '0')
    for (var i = 0; i < bits.length; i++) {
      this.setSingleBit(offset + i, parseInt(bits[i]))
    }
    return this
  }

  setSingleBit (offset, value) {
    var byte = (offset - (offset % 8)) / 8
    var mask = 1 << 7 - parseInt(offset % 8)
    value === 1 ? this[byte] |= mask : this[byte] &= ~mask
    return this
  }

  getSingleBit (offset) {
    var byte = (offset - (offset % 8)) / 8
    var mask = 1 << 7 - parseInt(offset % 8)
    if ((this[byte] & mask) !== 0) {
      return 1
    } else {
      return 0
    }
  }

  toString (radix = 16) {
    switch (radix) {
      case 'bin':
      case 2:
        return this.map(item => item.toString(2).padStart(8, '0')).join('')
      case 'dec':
      case 10:
        return this.map(item => item.toString(10).padStart(3, '0')).join('')
      case 'hex':
      case 16:
        return this.map(item => item.toString(16).padStart(2, '0')).join('')
    }
  }
}
ByteArray.from = function (...args) {
  var tmp = []
  args.forEach(item => {
    if (Number.isInteger(item) && item <= 255) {
      tmp.push(item)
    }
    if (Number.isInteger(item) && item > 255) {
      var t3 = ByteArray.from(item.toString(16))
      t3.forEach(x => {
        tmp.push(x)
      })
    }
    if (typeof item === 'string') {
      if (!/^[0-9abcdef]*$/.test(item)) {
        item.split('').forEach(x => {
          tmp.push(x.charCodeAt(0))
        })
        // throw new Error('String MAY only contain "0-9 a b c d e f"')
      } else {
        if (item.length % 2 !== 0) {
          item = `0${item}`
        }
        ((item.match(/.{1,2}/g) || []).map(item => parseInt(item, 16))).forEach(x => {
          tmp.push(x)
        })
      }
    }
    if (Array.isArray(item)) {
      var t2 = ByteArray.from(...item)
      t2.forEach(x => {
        tmp.push(x)
      })
    }
  })
  if (tmp.length === 1) {
    var res = new ByteArray()
    res[0] = tmp[0]
    return res
  } else {
    return new ByteArray(...tmp)
  }
}
export { ByteArray }
