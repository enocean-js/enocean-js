import { ByteArray } from '../../byte-array/src/byte-array.js'
import { ESP3Packet } from '../../esp3-packet/src/esp3-packet.js'
import { decode, getTeachInInfo, encodeData } from '../../eep-transcoder/src/eep-transcoder.js'

export const UTE_BIDIRECTIONAL = 0x01
export const UTE_UNIDIRECTIONAL = 0x00
export const UTE_TEACH_IN_SUCCESSFULL = 0x01
export const UTE_DELETION_SUCCESSFULL = 0x10
export const UTE_EEP_NOT_SUPPORTED = 0x11
export const UTE_TEACH_IN_NOT_ACCEPTED = 0x00
export const UTE_QUERY_TEACH_IN_REQUEST = 0x00
export const UTE_QUERY_DELETION_REQUEST = 0x01
export const UTE_QUERY_TEACH_IN_OR_DELETION = 0x10
export const UTE_QUERY_NOT_USED = 0x11
export const UTE_CMD_QUERY = 0x00
export const UTE_CMD_RESPONSE = 0x01

class RadioERP1 extends ESP3Packet {
  get packetType () {
    return 1
  }

  get RORG () {
    return super.data[0]
  }

  get payload () {
    return super.data.slice(1, super.data.length - 5)
  }

  set payload (data) {
    var newData = ByteArray.from(data)
    var oldData = ByteArray.from(super.data)
    oldData.splice(1, (super.dataLength - 6))
    oldData.splice(1, 0, ...newData)
    super.data = oldData
    super.fixPacket()
  }

  get senderId () {
    return super.data.slice(super.data.length - 5, super.data.length - 1).toString(16)
  }

  set senderId (id) {
    var idValue = ByteArray.from(id)
    idValue.length = 4
    var newData = ByteArray.from(super.data)
    newData.set(idValue, super.data.length - 5)
    super.data = newData
    super.fixPacket()
  }

  set status (val) {
    var dat = super.data
    dat[super.data.length - 1] = val
    super.data = dat
    super.fixPacket()
  }

  get status () {
    return super.data[super.data.length - 1]
  }

  get T21 () {
    return ByteArray.from(this.status).getSingleBit(2)
  }

  set T21 (val) {
    this.status = ByteArray.from(this.status).setSingleBit(2, val)[0]
    super.fixPacket()
  }

  get NU () {
    return ByteArray.from(this.status).getSingleBit(3)
  }

  set NU (val) {
    this.status = ByteArray.from(this.status).setSingleBit(3, val)[0]
    super.fixPacket()
  }

  get subTelNum () {
    return super.optionalData[0]
  }

  get destinationId () {
    return super.optionalData.slice(1, 5).toString(16)
  }

  set destinationId (id) {
    var idValue = ByteArray.from(id)
    idValue.length = 4
    var newData = ByteArray.from(super.optionalData)
    newData.set(idValue, super.optionalData.length - 6)
    super.optionalData = newData
    super.fixPacket()
  }

  get RSSI () {
    return super.optionalData[5]
  }

  get securityLevel () {
    return super.optionalData[6]
  }

  get teachIn () {
    var mask = 1 << 3
    if (this.RORG === 0xd5 || this.RORG === 0xa5) {
      return (this.payload[this.payload.length - 1] & mask) === 0
    }
    if (this.RORG === 0xd4 || this.RORG === 0xf6) return true
  }

  set teachIn (val) {
    this.payload = this.payload.setSingleBit((this.payload.length) * 8 - 4, val === true ? 0 : 1)
  }

  decode (eep, direction) {
    if (this.teachIn && this.RORG !== 0xf6) return this.teachInInfo
    return decode(this, eep, direction)
  }

  encode (data, options) {
    var opt = { ...options, ...{ payload: this.payload } }
    if ('status' in options) {
      this.status = options.status
    }
    this.payload = encodeData(data, opt)
    return this.payload
  }

  get teachInInfo () {
    return getTeachInInfo(this)
  }

  static makeTeachIn (opt) {
    var input = { ...{ eep: 'a5-02-01', manufacturerId: 0x7FF, bidi: 0, cmd: UTE_CMD_QUERY, destinationId: 'ffffffff', senderId: '00000000', responseRequired: 0, requestPayload: null, result: 1, channels: 0xff }, ...opt }
    var pl
    var rorg = input.type || parseInt(input.eep.split('-')[0], 16)
    var func = parseInt(input.eep.split('-')[1])
    var type = parseInt(input.eep.split('-')[2])
    if (Object.prototype.hasOwnProperty.call(input, 'eep')) {
      switch (rorg) {
        case 'RPS':
        case 0xf6:
          return RadioERP1.from({
            data: [0xf6, '00', input.senderId || '00000000', 0x20],
            optionalData: [3, 'ffffffff', 'ff', 0],
            packetType: 1
          })
        case '1BS':
        case 0xd5:
          return RadioERP1.from({
            data: [0xd5, '00', input.senderId || '00000000', 0],
            optionalData: [3, 'ffffffff', 'ff', 0],
            packetType: 1
          })
        case 'UTE':
        case 0xd4:
          rorg = parseInt(input.eep.split('-')[0], 16)
          var ret
          if (input.cmd === UTE_CMD_QUERY) {
            ret = RadioERP1.from({ rorg: 0xd4, payload: [0, 0, 0, 0, 0, 0] })
            ret.senderId = input.senderId
            ret.destinationId = input.destinationId
            ret.payload = ret.payload.setValue(input.bidi, 0, 1)
            ret.payload = ret.payload.setValue(input.result, 2, 2)
            ret.payload = ret.payload.setValue(input.channels, 8, 8)
            ret.payload = ret.payload.setValue(input.manufacturerId & 0xff, 16, 8)
            ret.payload = ret.payload.setValue((input.manufacturerId & 0xf00) >> 8, 29, 3)
            ret.payload = ret.payload.setValue(rorg, 48, 8)
            ret.payload = ret.payload.setValue(func, 40, 8)
            ret.payload = ret.payload.setValue(type, 32, 8)
            ret.payload = ret.payload.setValue(UTE_CMD_QUERY, 4, 4)
          } else {
            ret = RadioERP1.from({ rorg: 0xd4, payload: input.requestPayload })
            ret.senderId = input.senderId
            ret.destinationId = input.destinationId
            ret.payload = ret.payload.setValue(input.bidi, 0, 1)
            ret.payload = ret.payload.setValue(input.result, 2, 2)
            ret.payload = ret.payload.setValue(UTE_CMD_RESPONSE, 4, 4)
          }
          return ret
        default:
          pl = ByteArray.from('00000000')
          pl.setValue(parseInt(input.eep.split('-')[1], 16), 0, 6) // func
          pl.setValue(parseInt(input.eep.split('-')[2], 16), 6, 7) // type
          pl.setValue(input.manufacturerId || 0x7ff, 13, 11) // manufacturer
          pl.setValue(1, 24, 1) // set LRN type
          return RadioERP1.from({
            data: [0xa5, pl, input.senderId || '00000000', 0],
            optionalData: [3, 'ffffffff', 'ff', 0],
            packetType: 1
          })
      }
    }
  }

  static from (input) {
    var pl
    if (input.constructor.name === 'ESP3Packet') {
      return new RadioERP1(input.toString())
    }
    if (Object.prototype.hasOwnProperty.call(input, 'payload')) {
      var rorg
      pl = ByteArray.from(input.payload)
      switch (pl.length) {
        case 1:
          rorg = 0xf6
          break
        case 4:
          rorg = 0xa5
          break
        default:
          rorg = 0xd2
      }
      return RadioERP1.from({
        data: [input.rorg || rorg, pl, input.id || '00000000', input.status || 0],
        optionalData: [3, 'ffffffff', 'ff', 0], // always the same for sending ERP1
        packetType: 1 // always the same for sending ERP1
      })
    } else {
      var res = new RadioERP1(super.from(input).toString())
      return res
    }
  }
}
export default RadioERP1
export { RadioERP1 }
