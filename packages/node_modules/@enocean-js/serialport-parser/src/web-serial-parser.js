/* eslint-env browser */
import { ESP3Packet } from '../../esp3-packet/src/esp3-packet.js'
import * as CONST from './parser-const.js'
import { RadioERP1 } from '../../radio-erp1/src/radio-erp1.js'
import { CommonCommand } from '../../common-command/src/common-command.js'
import { Response } from '../../esp3-packets/src/packet-types/Response.js'
import { RadioERP2 } from '../../esp3-packets/src/packet-types/RadioERP2.js'
const packetTypes = {
  0x01: RadioERP1,
  0x02: Response,
  0x05: CommonCommand,
  0x0A: RadioERP2
}

class ESP3WebSerialParser extends EventTarget {
  constructor (options = { maxBufferSize: 65535 }) {
    super()
    this.currentESP3Packet = ESP3Packet.from()
    this.state = CONST.WAIT_FOR_SYNC_BYTE
    this.maxBufferSize = options.maxBufferSize
  }

  async read (reader) {
    var chunk = (await reader.read()).value
    for (var offset = 0; offset < chunk.length; offset++) {
      const byte = chunk[offset]
      switch (this.state) {
        case CONST.WAIT_FOR_SYNC_BYTE:
          if (byte === 0x55) {
            this.currentESP3Packet = ESP3Packet.from(byte)
            this.state = CONST.FILL_HEADER
          }
          break
        case CONST.FILL_HEADER:
          this.currentESP3Packet.push(byte)
          if (this.currentESP3Packet.length < 5) {
            break
          }
          this.state = CONST.CHECK_CRC8_HEADER
          break
        case CONST.CHECK_CRC8_HEADER:
          this.currentESP3Packet.push(byte)
          if (!this.currentESP3Packet.isHeaderOK()) {
            var syncCodeIndex = this.currentESP3Packet.findIndex((item, index) => { return (item === 0x55) && (index > 0) })
            if (syncCodeIndex > 0) {
              this.state = CONST.FILL_HEADER
              while (syncCodeIndex > 0) {
                this.currentESP3Packet.shift()
                syncCodeIndex--
              }
              break
            }
            // this.emit('error', {
            //   code: CONST.WRONG_HEADER_CHECKSUM_ERROR,
            //   name: 'WRONG_HEADER_CHECKSUM_ERROR',
            //   desc: 'header checksum test failed'
            // })
            this.state = CONST.WAIT_FOR_SYNC_BYTE
            break
          }
          if (this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength <= 0) {
            // this.emit('error', {
            //   code: CONST.ILLEGAL_PACKET_LENGTH_ERROR,
            //   name: 'ILLEGAL_PACKET_LENGTH_ERROR',
            //   desc: 'there must be at least 1 byte of data or optional data, it can not be 0'
            // })
            this.state = CONST.WAIT_FOR_SYNC_BYTE
            break
          }
          this.state = CONST.FILL_DATA_OPTIONALDATA
          break
        case CONST.FILL_DATA_OPTIONALDATA:
          this.currentESP3Packet.push(byte)
          if (this.currentESP3Packet.length > this.maxBufferSize) {
            this.state = CONST.WAIT_FOR_SYNC_BYTE
            // this.emit('error', {
            //   code: CONST.BUFFER_OVERFLOW_ERROR,
            //   name: 'BUFFER_OVERFLOW_ERROR',
            //   desc: `Max Buffer Size is ${this.maxBufferSize} Bytes`
            // })
            break
          }
          if (this.currentESP3Packet.length < this.currentESP3Packet.dataLength + this.currentESP3Packet.optionalLength + 6) {
            break
          }
          this.state = CONST.CHECK_CRC8_DATAS
          break
        case CONST.CHECK_CRC8_DATAS: {
          this.currentESP3Packet.push(byte)
          this.state = CONST.WAIT_FOR_SYNC_BYTE
          if (!this.currentESP3Packet.isBodyOK()) {
            // this.emit('error', {
            //   code: 2,
            //   name: 'WRONG_BODY_CHECKSUM',
            //   desc: 'data checksum test failed'
            // })
            break
          }
          let event
          if (this.currentESP3Packet.packetType in packetTypes) {
            const packet = packetTypes[this.currentESP3Packet.packetType].from(this.currentESP3Packet)
            event = new CustomEvent('data', { detail: packet })
          } else {
            event = new CustomEvent('data', { detail: this.currentESP3Packet })
          }

          this.dispatchEvent(event)
          // console.log(this.currentESP3Packet)
          // this.push(this.currentESP3Packet)
          break
        }
      }
    }
    this.read(reader)
  }
}
export default ESP3WebSerialParser
export { ESP3WebSerialParser }
